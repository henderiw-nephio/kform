package loader

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"

	"github.com/henderiw-nephio/kform/tools/pkg/util/sets"
	"golang.org/x/tools/go/packages"
)

type Loader interface {
	LoadRoots(roots ...string) ([]*Package, error)
}

func NewLoader() Loader {
	return NewWithConfig(nil)
}

// loader loads packages and their imports. Loaded packages will have
// type size, imports, and exports file information populated.
func NewWithConfig(cfg *packages.Config) Loader {
	if cfg == nil {
		cfg = &packages.Config{}
	}
	cfg.Mode |= packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedImports | packages.NeedTypesSizes
	if cfg.Fset == nil {
		cfg.Fset = token.NewFileSet()
	}
	// put our build flags first so that callers can override them
	cfg.BuildFlags = append([]string{"-tags", "ignore_autogenerated"}, cfg.BuildFlags...)

	return &loader{
		cfg:      cfg,
		packages: make(map[*packages.Package]*Package),
	}
}

// loader loads packages and their imports. Loaded packages will have
// type size, imports, and exports file information populated.
type loader struct {
	// Roots are the loaded "root" packages in the package graph loaded via
	// LoadRoots.
	Roots []*Package

	// cfg contains the package loading config
	cfg *packages.Config

	// packages contains the cache of Packages indexed by the underlying
	// package.Package, preventing duplicated package entries
	packages map[*packages.Package]*Package
	m        sync.Mutex
}

// This function will traverse Go module boundaries for roots that are file-
// system paths and end with "...". Please note this feature currently only
// supports roots that are filesystem paths. For more information, please
// refer to the high-level outline of this function's logic:
//
//  1. If no roots are provided then load the working directory and return
//     early.
func (l *loader) LoadRoots(roots ...string) ([]*Package, error) {
	// uniquePkgIDs is used to keep track of the discovered packages and try
	// to prevent packages from showing up twice when nested module
	// support is enabled.
	//uniquePkgIDs := sets.New[string]()
	uniquePkgIDs := sets.Set[string]{}

	// Visit the import graphs of the loaded, root packages. If an imported
	// package refers to another loaded, root package, then replace the
	// instance of the imported package with a reference to the loaded, root
	// package. This is required to make kubebuilder markers work correctly
	// when multiple root paths are loaded and types from one path reference
	// types from another root path.
	defer func() {
		for i := range l.Roots {
			visitImports(l.Roots, l.Roots[i], nil)
		}
	}()

	// loadPackages returns the Go packages for the provided roots
	loadPackages := func(roots ...string) ([]*Package, error) {
		rawPkgs, err := packages.Load(l.cfg, roots...)
		if err != nil {
			loadRoot := l.cfg.Dir
			if l.cfg.Dir == "" {
				loadRoot, _ = os.Getwd()
			}
			return nil, fmt.Errorf("load packages in root %q: %w", loadRoot, err)
		}
		var pkgs []*Package
		for _, rp := range rawPkgs {
			p := l.packageFor(rp)
			if !uniquePkgIDs.Has(p.ID) {
				pkgs = append(pkgs, p)
				uniquePkgIDs.Insert(p.ID)
			}
		}
		return pkgs, nil
	}

	// if no roots were provided then load the current package and return early
	if len(roots) == 0 {
		pkgs, err := loadPackages()
		if err != nil {
			return nil, err
		}
		l.Roots = append(l.Roots, pkgs...)
		return l.Roots, nil
	}

	// pkgRoots is a slice of roots that are package/modules and fspRoots
	// is a slice of roots that are local filesystem paths.
	//
	// please refer to this function's godoc comments for more information on
	// how these two types of roots are distinguished from one another
	var (
		pkgRoots  []string
		fspRoots  []string
		fspRootRx = regexp.MustCompile(`^\.{1,2}`)
	)
	for _, r := range roots {
		if filepath.IsAbs(r) || fspRootRx.MatchString(r) {
			fspRoots = append(fspRoots, r)
		} else {
			pkgRoots = append(pkgRoots, r)
		}
	}

	// handle the package roots by sending them into the packages.Load function
	// all at once. this is more efficient, but cannot be used for the file-
	// system path roots due to them needing a custom, calculated value for the
	// cfg.Dir field
	if len(pkgRoots) > 0 {
		pkgs, err := loadPackages(pkgRoots...)
		if err != nil {
			return nil, err
		}
		l.Roots = append(l.Roots, pkgs...)
	}

	// if there are no filesystem path roots then go ahead and return early
	if len(fspRoots) == 0 {
		return l.Roots, nil
	}

	//
	// at this point we are handling filesystem path roots
	//

	// ensure the cfg.Dir field is reset to its original value upon
	// returning from this function.
	defer func(d string) {
		l.cfg.Dir = d
	}(l.cfg.Dir)

	// store the value of cfg.Dir so we can use it later if it is non-empty.
	// we need to store it now as the value of cfg.Dir will be updated by
	// a loop below
	cfgDir := l.cfg.Dir

	// addNestedGoModulesToRoots is given to filepath.WalkDir and adds the
	// directory part of p to the list of filesystem path roots IFF p is the
	// path to a file named "go.mod"
	addNestedGoModulesToRoots := func(
		p string,
		d os.DirEntry,
		e error) error {

		if e != nil {
			return e
		}
		if !d.IsDir() && filepath.Base(p) == "go.mod" {
			fspRoots = append(fspRoots, filepath.Join(filepath.Dir(p), "..."))
		}
		return nil
	}

	// in the first pass over the filesystem path roots we:
	//
	//    1. make the root into an absolute path
	//
	//    2. check to see if a root uses the nested path syntax, ex. ...
	//
	//    3. if so, walk the root's descendants, searching for any nested Go
	//       modules
	//
	//    4. if found then the directory containing the Go module is added to
	//       the list of the filesystem path roots
	for i := range fspRoots {
		r := fspRoots[i]

		// clean up the root
		r = filepath.Clean(r)

		// get the absolute path of the root
		if !filepath.IsAbs(r) {

			// if the initial value of cfg.Dir was non-empty then use it when
			// building the absolute path to this root. otherwise use the
			// filepath.Abs function to get the absolute path of the root based
			// on the working directory
			if cfgDir != "" {
				r = filepath.Join(cfgDir, r)
			} else {
				ar, err := filepath.Abs(r)
				if err != nil {
					return nil, err
				}
				r = ar
			}
		}

		// update the root to be an absolute path
		fspRoots[i] = r

		b, d := filepath.Base(r), filepath.Dir(r)

		// if the base element is "..." then it means nested traversal is
		// activated. this can be passed directly to the loader. however, if
		// specified we also want to traverse the path manually to determine if
		// there are any nested Go modules we want to add to the list of file-
		// system path roots to process
		if b == "..." {
			if err := filepath.WalkDir(
				d,
				addNestedGoModulesToRoots); err != nil {

				return nil, err
			}
		}
	}

	// in the second pass over the filesystem path roots we:
	//
	//    1. determine the directory from which to execute the loader
	//
	//    2. update the loader config's Dir property to be the directory from
	//       step one
	//
	//    3. determine whether the root passed to the loader should be "./."
	//       or "./..."
	//
	//    4. execute the loader with the value from step three
	for _, r := range fspRoots {
		b, d := filepath.Base(r), filepath.Dir(r)

		// we want the base part of the path to be either "..." or ".", except
		// Go's filepath utilities clean paths during manipulation, removing the
		// ".". thus, if not "...", let's update the path components so that:
		//
		//   d = r
		//   b = "."
		if b != "..." {
			d = r
			b = "."
		}

		// update the loader configuration's Dir field to the directory part of
		// the root
		l.cfg.Dir = d

		// update the root to be "./..." or "./."
		// (with OS-specific filepath separator). please note filepath.Join
		// would clean up the trailing "." character that we want preserved,
		// hence the more manual path concatenation logic
		r = fmt.Sprintf(".%s%s", string(filepath.Separator), b)

		// load the packages from the roots
		pkgs, err := loadPackages(r)
		if err != nil {
			return nil, err
		}
		l.Roots = append(l.Roots, pkgs...)
	}

	return l.Roots, nil
}

// packageFor returns a wrapped Package for the given packages.Package,
// ensuring that there's a one-to-one mapping between the two.
// It's *not* threadsafe -- use packagesFor for that.
func (r *loader) packageFor(pkgRaw *packages.Package) *Package {
	if r.packages[pkgRaw] == nil {
		r.packages[pkgRaw] = &Package{
			Package: pkgRaw,
			loader:  r,
		}
	}
	return r.packages[pkgRaw]
}

// packagesFor returns a map of Package objects for each packages.Package in the input
// map, ensuring that there's a one-to-one mapping between package.Package and Package
// (as per packageFor).
func (l *loader) packagesFor(pkgsRaw map[string]*packages.Package) map[string]*Package {
	l.m.Lock()
	defer l.m.Unlock()

	out := make(map[string]*Package, len(pkgsRaw))
	for name, rawPkg := range pkgsRaw {
		out[name] = l.packageFor(rawPkg)
	}
	return out
}

// parseFile parses the given file, including comments.
func (l *loader) parseFile(filename string, src []byte) (*ast.File, error) {
	// skip function bodies
	file, err := parser.ParseFile(l.cfg.Fset, filename, src, parser.AllErrors|parser.ParseComments)
	if err != nil {
		return nil, err
	}

	return file, nil
}

// visitImports walks a dependency graph, replacing imported package
// references with those from the rootPkgs list. This ensures the
// kubebuilder marker generation is handled correctly. For more info,
// please see issue 680.
func visitImports(rootPkgs []*Package, pkg *Package, seen sets.Set[string]) {
	if seen == nil {
		seen = sets.Set[string]{}
	}
	for importedPkgID, importedPkg := range pkg.Imports() {
		for i := range rootPkgs {
			if importedPkgID == rootPkgs[i].ID {
				pkg.imports[importedPkgID] = rootPkgs[i]
			}
		}
		if !seen.Has(importedPkgID) {
			seen.Insert(importedPkgID)
			visitImports(rootPkgs, importedPkg, seen)
		}
	}
}

// NonVendorPath returns a package path that does not include anything before the
// last vendor directory.  This is useful for when using vendor directories,
// and using go/types.Package.Path(), which returns the full path including vendor.
//
// If you're using this, make sure you really need it -- it's better to index by
// the actual Package object when you can.
func NonVendorPath(rawPath string) string {
	parts := strings.Split(rawPath, "/vendor/")
	return parts[len(parts)-1]
}
